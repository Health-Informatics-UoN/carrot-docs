## Introduction
**ProcessQueue** refers to the Azure QueueTrigger function which executes  when a new message appears in the Scan Report queue. A new message is added when a Scan Report file is uploaded from the user. 

## Triggering the function
When a White Rabbit Scan Report file is uploaded on the site, it is saved into Azure Blob Storage and a message is send to the storage Queue. This message includes the `scan_report_id` from the `ScanReport` model and `blob_name` which is the name of the uploaded file.
![Queue Trigger](images/trigger.png)

**Figure 1** Triggering the Queue when uploading a Scan Report

## Accessing the File
As soon as the ProcessQueue is triggered it uses the `blob_name` from the message body to download the file from Azure Blob Storage into a BytesIO() object.

## Processing
The next step is to step through the Excel workbook and create model entries for each **ScanReportTable**, **ScanReportField** and **ScanReportValue** present in the file.

### Scan Report Table
The **Field Overview** sheet in a White Rabbit Scan Report has a 'Table' column which seperates different table names using a blank row. ProcessQueue main method iterates through the rows in the 'Table' column and appends each unique table name to the list `table_names`. 
For each table in `table_names` a new `ScanReportTable` entry is generated. The table entries are linked to the `ScanReport` model using the `scan_report_id` from the queue message body.
The table entries are then appended to a JSON array `json_data` which forms the input send in a POST request to the [API](API.md).
The API automatically generates the `id` for each table that was created. These ids are extracted from the POST request response and saved in a list (`table_ids`)

### Scan Report Field
**Field Overview** contains all the information on the fields including the name, description and other useful columns. ProcessQueue iterates through the rows in the sheet and generates a new `ScanReportField` entry. The field entries are linked to the relevant `ScanReportTable` using the previously generated `table_ids`. As soon as it detects an empty line (different table) it links to the next table_id from the list.
Similarly as in Scan Report Table the field entries are appended to a JSON array `json_data`, and form the input to a POST request made to the [API](API.md). From the response it saves the `field_ids` and `field_names` and stores them into a dictionary as key value pairs e.g "Field Name": Field ID.

### Scan Report Value
Scan report values are stored in sheets named after their corresponding table. For every sheet after the initial two 'Field Overview' and 'Table Overview'(not currently used), `process_scan_report_sheet_table()` is called. The function extracts the data in the following format:

**Input**

 Field A  | Frequency    | Field B  |Frequency
----------| -------------|----------|---------
  A | 20           | C  |5
  B | 3            | D  |37

**Output**

(Field A, A, 20)
(Field B, C, 5)
(Field A, B, 3)
(Field B, D, 37)

A ScanReportValue entry is generated by iterating through the output of `process_scan_report_sheet_table()`. The value entries are linked to the `ScanReportField` model using the function output and the dictionary with all the field names and ids. Same as with the other two models the value entries are appended to a JSON array `json_data`, and form the input to a POST request made to the [API](API.md).
